<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blood Emergency Map Background</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a0a;
        }

        #mapCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
        }
    </style>
</head>

<body>
    <canvas id="mapCanvas"></canvas>

    <script>
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Configuration
        const config = {
            nodeCount: 25,
            connectionDistance: 250,
            nodeRadius: 3,
            glowIntensity: 15,
            pulseSpeed: 0.002,
            zoomSpeed: 0.0003,
            cameraSpeed: 0.0002,
            redColor: '#ff2d55',
            redGlow: 'rgba(255, 45, 85, 0.6)',
            lineColor: 'rgba(255, 45, 85, 0.15)',
        };

        // Node class
        class Node {
            constructor() {
                this.baseX = Math.random() * canvas.width;
                this.baseY = Math.random() * canvas.height;
                this.x = this.baseX;
                this.y = this.baseY;
                this.pulseOffset = Math.random() * Math.PI * 2;
                this.pulseSpeed = 0.8 + Math.random() * 0.4;
                this.baseRadius = config.nodeRadius;
            }

            update(time, zoom, cameraX, cameraY) {
                // Apply zoom and camera movement
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                this.x = centerX + (this.baseX - centerX) * zoom + cameraX;
                this.y = centerY + (this.baseY - centerY) * zoom + cameraY;

                // Pulse effect
                const pulse = Math.sin(time * this.pulseSpeed + this.pulseOffset) * 0.5 + 0.5;
                this.currentRadius = this.baseRadius + pulse * 2;
                this.currentGlow = config.glowIntensity + pulse * 10;
            }

            draw() {
                // Outer glow
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.currentGlow
                );
                gradient.addColorStop(0, config.redGlow);
                gradient.addColorStop(0.5, 'rgba(255, 45, 85, 0.2)');
                gradient.addColorStop(1, 'rgba(255, 45, 85, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.currentGlow, 0, Math.PI * 2);
                ctx.fill();

                // Core node
                ctx.fillStyle = config.redColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.currentRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Create nodes
        const nodes = [];
        for (let i = 0; i < config.nodeCount; i++) {
            nodes.push(new Node());
        }

        // Animation variables
        let time = 0;
        let zoomPhase = 0;
        let cameraPhase = 0;

        // Draw connections
        function drawConnections() {
            ctx.strokeStyle = config.lineColor;
            ctx.lineWidth = 1;

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < config.connectionDistance) {
                        const opacity = 1 - (distance / config.connectionDistance);
                        ctx.strokeStyle = `rgba(255, 45, 85, ${opacity * 0.15})`;

                        ctx.beginPath();
                        ctx.moveTo(nodes[i].x, nodes[i].y);
                        ctx.lineTo(nodes[j].x, nodes[j].y);
                        ctx.stroke();
                    }
                }
            }
        }

        // Animation loop
        function animate() {
            // Clear canvas with fade effect for smooth trails
            ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update animation phases
            time += config.pulseSpeed;
            zoomPhase += config.zoomSpeed;
            cameraPhase += config.cameraSpeed;

            // Calculate zoom (smooth sine wave between 0.9 and 1.1)
            const zoom = 1 + Math.sin(zoomPhase) * 0.1;

            // Calculate camera movement (subtle circular motion)
            const cameraX = Math.cos(cameraPhase) * 30;
            const cameraY = Math.sin(cameraPhase * 1.3) * 20;

            // Update and draw nodes
            nodes.forEach(node => {
                node.update(time, zoom, cameraX, cameraY);
            });

            // Draw connections first (behind nodes)
            drawConnections();

            // Draw nodes on top
            nodes.forEach(node => {
                node.draw();
            });

            requestAnimationFrame(animate);
        }

        // Start animation
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            // Reposition nodes proportionally
            nodes.forEach(node => {
                node.baseX = (node.baseX / canvas.width) * window.innerWidth;
                node.baseY = (node.baseY / canvas.height) * window.innerHeight;
            });
        });
    </script>
</body>

</html>